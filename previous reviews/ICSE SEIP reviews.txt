Review 1

Summary of the paper:	

The paper presents an approach to systematically explore tradeoffs between various parameters in a software system, based on type classes implemented in Coq. The approach is instantiated on the specific problem of optimising database schemas generated by an ORM such as Django or Rails. The approach is evaluated on 5 case studies: 4 case studies from the literature, and one case study from an industrial system whose code is available on line. The approach demonstrates improvements on the first four systems (in terms of time to sore and retrieve data, and space), but has no improvement on the last case.

Short list of the paper's strengths and weaknesses:

+ Paper quite accessible to the layman
+ Approach is quite effective on 80% of the case studies

- Tangential to the SEIP track (no real application in an industrial setting)
- Relation to SBSE should be made explicit


Detailed evaluation of the paper:

Let me start by saying that I find the work quite impressive, even if my final recommendation is negative.

I appreciate the effort that was made to make this kind of work (often very formal) accessible to a broader audience; this is certainly welcome in the context of this track. 

However, I have strong doubts as to whether the paper should be accepted, because it does not make a strong case as applying the presented approach "in practice". The closest thing this paper has is that it has been applied to one industrial system (out of five), in an experimental setting. The proposed changes have not been incorporated in said system, as far as I could ascertain (and I would be surprised if they would, given that this is the only one of the case studies where the approach was not effective).

Regarding the lack of effectiveness on this particular case, I would have liked to see a more detailed explanation of the reasons of this phenomenon: there is one sentence about this in the paper, while I would have expected much more details about this (more concrete explanations, discussion on how common it is to have models with the same characteristics as flagship docs, etc).

Finally, I was quite surprised at the lack of references on Search-Based Software Engineering. This is a large and mature field that does exactly what this paper does (searching an optimal solution in a set of candidates solutions), using similar concepts (e.g. the Pareto Front). There is related work on synthesis, but nothing about SBSE (except one work on genetic programming, but SBSE is not even mentioned by name in the paper).



Review 2

Summary of the paper:

The authors constructed a tool for modeling and analyzing elements of the tradespace, i.e. tradeoffs among nonfunctional requirements, and apply that to the specific problem of assessing methods for database schema synthesis. In this example, the trade offs investigated are time to perform database operations versus space consumption. The authors show that, for several small examples, their method performs better than state-of-the-practice methods.

Short list of the paper's strengths and weaknesses:	
+ Permitting developers to conduct systematic tradeoff analyses is an important and practical goal.
+ Real data are included to demonstrate the utility of the method described.

- The investigation is limited and the connection to larger tradespace issues is nebulous. This really should have been positioned as a paper about a database schema tool, not a tradeoff analysis approach.
- The projects used in the collection of data are small and unrepresentative of industrial practice - Thus I feel this paper is not a good fit for the SEIP track.

Detailed evaluation of the paper:

I do not feel that this work is relevant to the SEIP track. The studies are done on toy problems, not with examples from real practice. There are no references included to indicate that database schema synthesis is a widespread, impactful problem in practice, and that the improvements shown due to the authors' method would lead to any practical impact. There are no practitioners on the author list, and no real-world data or documents are used in the research.

Furthermore, the tradespace discussion is a compelling one, but only very loosely tied to the actual technical work. Tradespace discussions almost always (at least in my experience) occur at the macro level, and discuss the system's ability to deliver key capabilities to the user. While it may be useful in some specialized contexts to examine specific and low-level implementation details as was done here, this is not what has ever been intended in any "tradespace modeling" that I have participated in. The authors admit that they have no evidence that their methodology is indicative of a more general tradeoff methodology. (Section VI.A., "For this claim, we have only limited supporting data.") For this reason, I think it would have been better positioned as a paper on a specific database schema synthesis tool.

The English needs to be improved. It was difficult to understand the technical discussion in several places because of language issues.


Review 3

Summary of the paper:	
Designer go straight to a familiar design; a tool can explore a much wider range of alternative and provide ways to trade off between different aspects. This paper explore one simple case of this, from a theoretical perspective, and provides an experiment as a proof-of-concept.

Short list of the paper's strengths and weaknesses:	

Strong point:
+ interesting topic, good motivation
+ nice experiment 

Weak point:
- what is the value for the practitioner? How is this “software engineering in practice"? This looks like rather abstract academic research, leading to no practical, usable tool or technique by the practitioner.
- This paper is not in the right track


Detailed evaluation of the paper:	

Introduce Pareto-optimal in your context. what is a pareto-optimal solution here?

I have a hard time seeing the practitioner doing what is described in the section IV b) which itself involve making some design decisions.

Is really the best design the one that runs faster? (I would say that in most cases, it is the one that is the easiest to understand by the designer san the people who will have to maintain the code for 20 years).

In IV.c what “dashed line” are you speaking about?

Figure 3, 6, 7,8: image definition not sufficient to read. hard to find the red triangle and the aqua (blue) triangle in 6
Listing 1 and 2: what is the value for the practitioner

Figure 3: what is this telling the reader? Yes, Django and rails produce one, you are producing 8, so what? Producing many was not the objective of the tool developers.

I do not see the value of citation in green (very hard to read).

top of page 2: typos…? dtagram, Our…